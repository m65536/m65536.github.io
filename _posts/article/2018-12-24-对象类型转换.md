* [存在继承关系的Java类对象之间的类型转换(一)](http://www.cnblogs.com/lubocsu/p/5101022.html)

## fastjson转换
````$xslt
            EventMessage endMsg = JSONObject.parseObject(resultBody, EventMessage.class);
            Map obj = JSONObject.parseObject(endMsg.getAttachment(), HashMap.class);
            String promotionId = obj.get("promotionId") == null ? null : obj.get("promotionId").toString();
            String status = obj.get("status") == null ? null : obj.get("status").toString();
            String promotionType = obj.get("promotionType") == null ? null : obj.get("promotionType").toString();
            String sku = obj.get("skuNo") == null ? null : obj.get("skuNo").toString();//付非券过期
````

类似于基本数据类型之间的强制类型转换。 
存在继承关系的父类对象和子类对象之间也可以 
在一定条件之下相互转换。 
这种转换需要遵守以下原则： 
1.子类对象可以被视为是其父类的一个对象
2.父类对象不能被当作是某一个子类的对象。
3.如果一个方法的形式参数定义的是父类对象,那么调用这个方法时,可以使用子类对象作为实际参数。 
4.如果父类对象与引用指向的实际是一个子类对象,那么这个父类对象的引用可以用强制类型转换转化成子类对象的引用。

 方法一：

 1.  Child a = new Child();

 2.  Parent b = a;

 3.  Child c = (Child) b;

 该方法的步骤是： 1.创建1个子类对象

                          2.用超类引用该子类对象

                          3.另外1个子类引用将该超类引用强制的转换。

 采用该方法的过程中：由于超类引用的是1个子类对象（引用的该子类对象的内存空间），因此该超类引用具备子类对象的特点，再将该超类引用强制转化为另外1个子类对象。 

 采用该方法可以实现对象类型由超类向子类的转化，并且在程序的编译和运行均不会出现异常。

方法二：（错误方法）

 1.Parent b = new parent();

 2.Child c = (Child) b ;

       采用该方法不能实现对象类型由超类向子类的转化，以上源程序编译正常，但是运行时会抛出class castException异常。

      这是因为：可以执行类型转换“子＝（子）父”，但需要运行时进行检查。如果父类变量引用的是正确的子类型（这句话的意思即为描述1中的内容：即父类对象要想造型转换后赋给子类对象，其本身引用的是子类型的内存空间），赋值将执行。如果父类变量引用的是不相关的子类型，将会生成class castException异常。

 

在java中，做强制类型转换时
父类与子类对象之间，同一父类的兄弟类对象之间如何强制转换？
例如：
class a
{ ... }
class b extends a
{...}
class c extends a
{...}
....
a a1=new a();
b b1=new b();
c c1=new c();
a1=b1    //合法
b1=a1    //不合法（理论上是合法的？）
b1=(b)c1//不合法（理论上是合法的？）

解答：

说明以下几点:
1.类型转换必须在继承层次类转换,即超类与子类之间.
2.兄弟类之间不存在继承,因此也不存在类型转换.

对类进行类型转换的一般原则如下：
1.总是可以“父＝子”赋值。此时不需要类型转换。因为特定的子类也属于它的一般父类。也可以执行跨级跨层次的赋值，即父类可以式更高级别的父类。
2.可以执行类型转换“子＝（子）父”，但需要运行时进行检查。如果父类变量引用的是正确的子类型，赋值将执行。如果父类变量引用的是不相关的子类型，将会生成class castException异常。
3.决不能在不相关的任何类之间执行类的赋值或者类型转换。
如果把搂主的a1当作动物，把b1当作狗，c1当作猫
a1=b1    //合法———也就是说狗是动物，当然成立
b1=a1    //不合法（理论上是合法的？）———就是说动物是狗，这当然不对了
b1=(b)c1//不合法（理论上是合法的？）———就是说狗是猫，这当然也不对了

 

对象在继承关系中的改变

对象的赋值是地址标识的传递，即两个对象名共同使用同一段内存地址。在Java中，对父类与子类对象之间的赋值作了如下规定：

1、子类对象名可以赋值给父类对象名；但父类对象名不可以赋值给子类对象名。

即：父类对象名=子类对象名;

2、如果一个父类对象名已经被子类对象名所赋值，那可以将父类对象名经强制转换赋值给子类对象名。

即：子类对象名=(子类类名)父类对象名;

常用的一种形式：方法中形参用父类型，实参用子类的对象名.

 

总结：

对类进行造型转换的应参考以下原则：
1.总是可以“父＝子”赋值。此时不需要类型转换。
2.可以执行类型转换“子＝（子）父”，但需要运行时进行检查。如果父类变量引用的是正确的子类型，赋值将执行。如果父类变量引用的是不相关的子类型，将会生成class castException异常。
即：如果父类的实例是在子类的实例上塑造的，“子＝（子）父”时就不会抛出异常。  
如：
A 是B的父类。
A a= new B(); //父类A的对象a是在子类B的对象上塑造的。
就可以：
B b= (B)a;
3.决不能在不相关的任何类之间执行类的赋值或者类型转换。即类的造型转换仅限于有继承关系的俩个类的对象之间。